<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.ogf.org/pipermail/occi-wg/2009-May/000395.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 20 Oct 2022 22:35:22 GMT -->
<HEAD>
   <TITLE> [occi-wg] Is OCCI the HTTP of Cloud Computing?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:occi-wg%40ogf.org?Subject=%5Bocci-wg%5D%20Is%20OCCI%20the%20HTTP%20of%20Cloud%20Computing%3F&In-Reply-To=21606dcf0905041833t2336db99q7827e1ac944f3193%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="https://www.ogf.org/pipermail/occi-wg/2009-May/000399.html">
   <LINK REL="Next"  HREF="https://www.ogf.org/pipermail/occi-wg/2009-May/000403.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[occi-wg] Is OCCI the HTTP of Cloud Computing?</H1>
    <B>Sam Johnston</B> 
    <A HREF="mailto:occi-wg%40ogf.org?Subject=%5Bocci-wg%5D%20Is%20OCCI%20the%20HTTP%20of%20Cloud%20Computing%3F&In-Reply-To=21606dcf0905041833t2336db99q7827e1ac944f3193%40mail.gmail.com"
       TITLE="[occi-wg] Is OCCI the HTTP of Cloud Computing?">samj at samj.net
       </A><BR>
    <I>Wed May  6 08:37:47 CDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="https://www.ogf.org/pipermail/occi-wg/2009-May/000399.html">[occi-wg] Is OCCI the HTTP of Cloud Computing?
</A></li>
        <LI>Next message: <A HREF="https://www.ogf.org/pipermail/occi-wg/2009-May/000403.html">[occi-wg] Is OCCI the HTTP of Cloud Computing?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="https://www.ogf.org/pipermail/occi-wg/2009-May/date.html#395">[ date ]</a>
              <a href="https://www.ogf.org/pipermail/occi-wg/2009-May/thread.html#395">[ thread ]</a>
              <a href="https://www.ogf.org/pipermail/occi-wg/2009-May/subject.html#395">[ subject ]</a>
              <a href="https://www.ogf.org/pipermail/occi-wg/2009-May/author.html#395">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ok so for the record, here's a thread between Ben Black and myself
discussing XML v JSON:

Sam,

I'm hoping there is more to the various decisions than is outlined in this
post. &quot;Everyone is doing it&quot; is illustrative, but not convincing.

XML drags along an awful lot of baggage, which has resulted in many folks
using lighter-weight formats like JSON. ATOM, in turns, lards still more
baggage into the mix, again, without any clear advantage in this
application. Finally, OAuth is very much in flux, as the recent security
incident makes painfully clear, and, once again, its compelling advantage in
this scenario is not covered above.

The Sun Cloud API work is extremely solid and goes towards simplicity in
almost every choice. Why are you ignoring it?

Ben


G'day Ben,

Au contraire, we are paying *very* close attention to the Sun Cloud APIs and
originally wanted to draw from them heavily were it not for a disagreement
with the OGF powers that be over Creative Commons licensing. Nonetheless we
have learnt a lot from them about high level concepts such as having a
single entry point and &quot;buttons&quot; for state changes and the like. We are also
looking at simple text based APIs like those used at ElasticHosts and GoGrid
(and of course Amazon).

Sun's decision to use JSON no doubt stems from the fact that the API was
previously consumed almost exclusively by the Q-Layer web interface - it is
not so clear that it is the best choice when you stray from the web and
native JavaScript environments, particularly when you want to (safely)
support extensibility... XML allows users to extend the API as necessary in
a fashion that can be validated and will not break other extensions.

Another reasonably firm requirement is that it be possible/trivial to script
the interface for e.g. sysadmin tasks... for this we need a simple text
based protocol anyway so we already have to support more than one output
format (which is increasingly common today, even if not particularly
elegant).

Finally, given that technology is only half the battle (the other half being
marketing/politics), it's necessary to cater to the needs of enterprise
users who are well used to horrors like WS-* and who will find a lightweight
XML layer refreshingly simple in comparison to the status quo. More
importantly though, enterprise requirements like validation, signing,
encryption, etc. are natively supported by XML and not (easily) supported
for the alternatives.

Oh and we are not at all wedded to OAuth - any HTTP authentication mechanism
will do (though it may make sense for us to limit this somewhat for
interoperability).

For more specific details check out the
wiki&lt;<A HREF="http://forge.ogf.org/sf/wiki/do/viewPage/projects.occi-wg/wiki/HomePage">http://forge.ogf.org/sf/wiki/do/viewPage/projects.occi-wg/wiki/HomePage</A>&gt;and/or
get involved yourself.

Sam


Sam,

The onus is on you to justify the additional complexity. Rejecting simpler
solutions because they are unfamiliar is dangerous.

While JSON might have initially entered the protocol via Q-Layer, the
current state of the work is miles from those origins. JSON has similarly
moved well beyond its origins as something used by Javascript (see CouchDB
for a great example). Finally, it is a simple, text-based system, far
simpler than XML, and I have recent, painful experience in working in JSON
and XML simultaneously for systems management. It's a no brainer: JSON wins
in that space because it is easier to write, easier to read, and a lot
harder to make poor, structural decisions using it.

Enterprises currently use a lot of XML because that is what vendors like
Microsoft foisted on them in the name of &quot;standards&quot;. If you adopt all the
existing validation and security stack for XML, you are so close to WS-* as
to be indistinguishable. This work will fail if all it does is produce
&quot;WS-Cloud&quot;, and that is very much the path on which you are placing it with
these choices. You can do better.

Ben


Ben,

Thanks for your ongoing interest in this topic - your opinion is valued (and
not just by me) so I would very much like us to be on the same wavelength.

I've since been looking at CouchDB which is a very interesting project given
one of the design patterns I've been keeping in mind is a database driven
controller (that is, OCCI being a direct interface to the database) with
triggers firing off e.g. AMQP messages for state changes et al. Erlang is
the obvious choice for such infrastructure and it seems like CouchDB has
done a lot of the work already. Of course it's well out of scope for the
spec itself but it's useful to consider how it might be realised.

In terms of the XML vs JSON bikeshed &lt;<A HREF="http://www.bikeshed.com/">http://www.bikeshed.com/</A>&gt; (and I say
bikeshed because once you have to reach for library, as is the case for both
XML and JSON, you may as well use ASN.1 on the wire for all it matters), I
have many reasons for preferring XML, not the least of which is the ease at
which it can be trivially converted to $PREFERRED_FORMAT using tools and
expertise that already exists (the same cannot necessarily be said for the
reverse, or between other formats). Very few enterprise developers have JSON
exposure, let alone experience, and it's not surprising given that essential
features such as schemas &lt;<A HREF="http://www.json.com/json-schema-proposal/">http://www.json.com/json-schema-proposal/</A>&gt; and
validation are still in a state of flux. Incidentally one thing I *do* like
about YAML (and to a lesser extent, JSON) is the relative ease at which even
complex data structures can be represented - this does provide more rope
with which to hang oneself though.

This brings us to the specifics of the proposal... XML can be [ab]used in so
many different ways it's worth pointing out that the proposal uses it in the
simplest way possible. Atom giving us just enough structure to link objects
together, categorise them and provide metadata (such as owners, etags for
caching, etc.) - as Andy observed it's more of a meta-model than anything
else and we found that much of what we were trying to do was reinventing the
[Atom] wheel. The actual content itself (cpu, memory, etc.) is simple,
easily readable, and in all cases so far, flat... as such it's more a
question of whether we use angle brackets or curly braces :)

So why go for angle brackets (XML) over curly braces (JSON) given most of
the action is going on in the latter camp? In addition to the reasons given
above, Google. That is, if we essentially rubber stamp GData (a well proven
protocol) in the form of OCCI core then it's just a matter of changing (or
supporting multiple) namespaces and we may well be able to get Google on
board along with a raft of running code. I've already been discussing this
with Google's API gurus and product managers this week and while there's no
commitment there is some amount of interest.

As for WS-Cloud, I assure you this is nothing like it... I wonder when
reading the WS-[death]* specs whether they weren't deliberately obfuscated
in some cases and even the better ones like
WS-Agreement&lt;<A HREF="http://samj.net/2009/05/www.ogf.org/documents/GFD.107.pdf">http://samj.net/2009/05/www.ogf.org/documents/GFD.107.pdf</A>&gt;are
[over]complicated, in this case running out to dozens of pages.

Sam

On Tue, May 5, 2009 at 3:33 AM, Sam Johnston &lt;<A HREF="http://www.ogf.org/mailman/listinfo/occi-wg">samj at samj.net</A>&gt; wrote:

&gt;<i> Morning all,
</I>&gt;<i>
</I>&gt;<i> I'm going to break my own rules about reposting blog posts because this is
</I>&gt;<i> very highly relevant, it's 03:30am already and I'm traveling again tomorrow.
</I>&gt;<i> The next step for us is to work out what the protocol itself will look like
</I>&gt;<i> on the wire, which is something I have been spending a good deal of time
</I>&gt;<i> looking at over many months (both analysing existing efforts and thinking of
</I>&gt;<i> &quot;blue sky&quot; possibilities).
</I>&gt;<i>
</I>&gt;<i> I am now 100% convinced that the best results are to be had with a variant
</I>&gt;<i> of XML over HTTP (as is the case with Amazon, Google, Sun and VMware) and
</I>&gt;<i> that while Google's GData is by far the most successful cloud API in terms
</I>&gt;<i> of implementations, users, disparate services, etc. Amazon's APIs are (at
</I>&gt;<i> least for the foreseeable future) a legal minefield. I'm also very
</I>&gt;<i> interested in the direction Sun and VMware are going and have of course been
</I>&gt;<i> paying very close attention to existing public clouds like ElasticHosts and
</I>&gt;<i> GoGrid (with a view to being essentially backwards compatible and sysadmin
</I>&gt;<i> friendly).
</I>&gt;<i>
</I>&gt;<i> I think the best strategy by a country mile is to standardise OCCI core
</I>&gt;<i> protocol following Google's example (e.g. base it on Atom and/or AtomPub
</I>&gt;<i> with additional specs for search, caching, etc.), build IaaS extensions in
</I>&gt;<i> the spirit of Sun/VMware APIs and support alternative formats including
</I>&gt;<i> HTML, JSON and TXT via XML Stylesheets (e.g. occi-to-html.xsl&lt;<A HREF="http://code.google.com/p/occi/source/browse/trunk/xml/occi-to-html.xsl">http://code.google.com/p/occi/source/browse/trunk/xml/occi-to-html.xsl</A>&gt;,
</I>&gt;<i> occi-to-json.xsl&lt;<A HREF="http://code.google.com/p/occi/source/browse/trunk/xml/occi-to-json.xsl">http://code.google.com/p/occi/source/browse/trunk/xml/occi-to-json.xsl</A>&gt;and
</I>&gt;<i> occi-to-text.xsl&lt;<A HREF="http://code.google.com/p/occi/source/browse/trunk/xml/occi-to-text.xsl">http://code.google.com/p/occi/source/browse/trunk/xml/occi-to-text.xsl</A>&gt;).
</I>&gt;<i> You can see the basics in action thanks to my Google App Engine reference
</I>&gt;<i> implementation&lt;<A HREF="http://code.google.com/p/occi/source/browse/#svn/trunk/occitest">http://code.google.com/p/occi/source/browse/#svn/trunk/occitest</A>&gt;at
</I>&gt;<i> <A HREF="http://occitest.appspot.com/">http://occitest.appspot.com/</A> (as well as HTML&lt;<A HREF="http://www.w3.org/2005/08/online_xslt/xslt?xslfile=http%3A%2F%2Focci.googlecode.com%2Fsvn%2Ftrunk%2Fxml%2Focci-to-html.xsl&amp;xmlfile=http%3A%2F%2Foccitest.appspot.com">http://www.w3.org/2005/08/online_xslt/xslt?xslfile=http%3A%2F%2Focci.googlecode.com%2Fsvn%2Ftrunk%2Fxml%2Focci-to-html.xsl&amp;xmlfile=http%3A%2F%2Foccitest.appspot.com</A>&gt;,
</I>&gt;<i> JSON&lt;<A HREF="http://www.w3.org/2005/08/online_xslt/xslt?xslfile=http%3A%2F%2Focci.googlecode.com%2Fsvn%2Ftrunk%2Fxml%2Focci-to-json.xsl&amp;xmlfile=http%3A%2F%2Foccitest.appspot.com">http://www.w3.org/2005/08/online_xslt/xslt?xslfile=http%3A%2F%2Focci.googlecode.com%2Fsvn%2Ftrunk%2Fxml%2Focci-to-json.xsl&amp;xmlfile=http%3A%2F%2Foccitest.appspot.com</A>&gt;and
</I>&gt;<i> TXT&lt;<A HREF="http://www.w3.org/2005/08/online_xslt/xslt?xslfile=http%3A%2F%2Focci.googlecode.com%2Fsvn%2Ftrunk%2Fxml%2Focci-to-text.xsl&amp;xmlfile=http%3A%2F%2Foccitest.appspot.com">http://www.w3.org/2005/08/online_xslt/xslt?xslfile=http%3A%2F%2Focci.googlecode.com%2Fsvn%2Ftrunk%2Fxml%2Focci-to-text.xsl&amp;xmlfile=http%3A%2F%2Foccitest.appspot.com</A>&gt;versions of same), KISS junkies bearing in mind that this weighs in under
</I>&gt;<i> 200 lines of python code! Of particular interest is the ease at which
</I>&gt;<i> arbitrarily complex [X]HTML interfaces can be built directly on top of OCCI
</I>&gt;<i> (optionally rendered from raw XML in the browser itself) and the use of the
</I>&gt;<i> hCard microformat &lt;<A HREF="http://microformats.org/">http://microformats.org/</A>&gt; as a simple demonstration of
</I>&gt;<i> what is possible.
</I>&gt;<i>
</I>&gt;<i> Anyway, without further ado:
</I>&gt;<i>
</I>&gt;<i> Is OCCI the HTTP of Cloud Computing?
</I>&gt;<i> <A HREF="http://samj.net/2009/05/is-occi-http-of-cloud-computing.html">http://samj.net/2009/05/is-occi-http-of-cloud-computing.html</A>
</I>&gt;<i>
</I>&gt;<i> The Web is built on the Hypertext Transfer Protocol (HTTP)&lt;<A HREF="http://en.wikipedia.org/wiki/HTTP">http://en.wikipedia.org/wiki/HTTP</A>&gt;,
</I>&gt;<i> a client-server protocol that simply allows client user agents to retrieve
</I>&gt;<i> and manipulate resources stored on a server. It follows that a single
</I>&gt;<i> protocol could prove similarly critical for Cloud Computing&lt;<A HREF="http://en.wikipedia.org/wiki/Cloud_computing">http://en.wikipedia.org/wiki/Cloud_computing</A>&gt;,
</I>&gt;<i> but what would that protocol look like?
</I>&gt;<i>
</I>&gt;<i> The first place to look for the answer is limitations in HTTP itself. For a
</I>&gt;<i> start the protocol doesn't care about the payload it carries (beyond its Internet
</I>&gt;<i> media type &lt;<A HREF="http://en.wikipedia.org/wiki/Internet_media_type">http://en.wikipedia.org/wiki/Internet_media_type</A>&gt;, such as
</I>&gt;<i> text/html), which doesn't bode well for realising the vision&lt;<A HREF="http://www.w3.org/2001/sw/Activity.html">http://www.w3.org/2001/sw/Activity.html</A>&gt;of the [
</I>&gt;<i> Semantic &lt;<A HREF="http://en.wikipedia.org/wiki/Semantic_Web">http://en.wikipedia.org/wiki/Semantic_Web</A>&gt;] Web&lt;<A HREF="http://en.wikipedia.org/wiki/World_Wide_Web">http://en.wikipedia.org/wiki/World_Wide_Web</A>&gt;as a &quot;universal medium for the exchange of data&quot;. Surely it should be
</I>&gt;<i> possible to add some structure to that data in the simplest way possible,
</I>&gt;<i> without having to resort to carrying complex, opaque file formats (as is the
</I>&gt;<i> case today)?
</I>&gt;<i>
</I>&gt;<i> Ideally any such scaffolding added would be as light as possible, providing
</I>&gt;<i> key attributes common to all objects (such as updated time) as well as basic
</I>&gt;<i> metadata such as contributors, categories, tags and links to alternative
</I>&gt;<i> versions. The entire web is built on hyperlinks so it follows that the
</I>&gt;<i> ability to link between resources would be key, and these links should be
</I>&gt;<i> flexible such that we can describe relationships in some amount of detail.
</I>&gt;<i> The protocol would also be capable of carrying opaque payloads (as HTTP does
</I>&gt;<i> today) and for bonus points transparent ones that the server can seamlessly
</I>&gt;<i> understand too.
</I>&gt;<i>
</I>&gt;<i> Like HTTP this protocol would not impose restrictions on the type of data
</I>&gt;<i> it could carry but it would be seamlessly (and safely) extensible so as to
</I>&gt;<i> support everything from contacts to contracts, biographies to books (or
</I>&gt;<i> entire libraries!). Messages should be able to be serialised for storage
</I>&gt;<i> and/or queuing as well as signed and/or encrypted to ensure security.
</I>&gt;<i> Furthermore, despite significant performance improvements introduced in HTTP
</I>&gt;<i> 1.1 it would need to be able to stream many (possibly millions) of objects
</I>&gt;<i> as efficiently as possible in a single request too. Already we're asking a
</I>&gt;<i> lot from something that must be extremely simple and easy to understand.
</I>&gt;<i>
</I>&gt;<i> XML
</I>&gt;<i>
</I>&gt;<i> It doesn't take a rocket scientist to work out that this &quot;new&quot; protocol is
</I>&gt;<i> going to be XML based, building on top of HTTP in order to take advantage of
</I>&gt;<i> the extensive existing infrastructure. Those of us who know even a little
</I>&gt;<i> about XML will be ready to point out that the &quot;X&quot; in XML means &quot;eXtensible&quot;
</I>&gt;<i> so we need to be specific as to the schema for this assertion to mean
</I>&gt;<i> anything. This is where things get interesting. We could of course go down
</I>&gt;<i> the WS-* route and try to write our own but surely someone else has crossed
</I>&gt;<i> this bridge before - after all, organising and manipulating objects is one
</I>&gt;<i> of the primary tasks for computers.
</I>&gt;<i>
</I>&gt;<i> Who better to turn to for inspiration than a company whose mission&lt;<A HREF="http://www.google.com/corporate/">http://www.google.com/corporate/</A>&gt;it is to &quot;organize the world's information and make it universally
</I>&gt;<i> accessible and useful&quot;, Google. They use a single protocol for almost all of
</I>&gt;<i> their APIs, GData &lt;<A HREF="http://code.google.com/apis/gdata/">http://code.google.com/apis/gdata/</A>&gt;, and while people
</I>&gt;<i> don't bother to look under the hood (no doubt thanks to the myriad client
</I>&gt;<i> libraries &lt;<A HREF="http://code.google.com/apis/gdata/clientlibs.html">http://code.google.com/apis/gdata/clientlibs.html</A>&gt; made
</I>&gt;<i> available under the permissive Apache 2.0 license), when you do you may be
</I>&gt;<i> surprised at what you find: everything from contacts to calendar items, and
</I>&gt;<i> pictures to videos is a feed (with some extensions for things like
</I>&gt;<i> searching&lt;<A HREF="http://code.google.com/apis/gdata/docs/2.0/basics.html#Searching">http://code.google.com/apis/gdata/docs/2.0/basics.html#Searching</A>&gt;and
</I>&gt;<i> caching&lt;<A HREF="http://code.google.com/apis/gdata/docs/2.0/reference.html#ResourceVersioning">http://code.google.com/apis/gdata/docs/2.0/reference.html#ResourceVersioning</A>&gt;
</I>&gt;<i> ).
</I>&gt;<i>
</I>&gt;<i> OCCI
</I>&gt;<i>
</I>&gt;<i> Enter the OGF's Open Cloud Computing Interface (OCCI)&lt;<A HREF="http://www.occi-wg.org/">http://www.occi-wg.org/</A>&gt;whose (initial) goal it is to provide an extensible interface to Cloud
</I>&gt;<i> Infrastructure Services (IaaS). To do so it needs to allow clients to
</I>&gt;<i> enumerate and manipulate an arbitrary number of server side &quot;resources&quot;
</I>&gt;<i> (from one to many millions) all via a single entry point. These compute,
</I>&gt;<i> network and storage resources need to be able to be created, retrieved,
</I>&gt;<i> updated and deleted (CRUD) and links need to be able to be formed between
</I>&gt;<i> them (e.g. virtual machines linking to storage devices and network
</I>&gt;<i> interfaces). It is also necessary to manage state (start, stop, restart) and
</I>&gt;<i> retrieve performance and billing information, among other things.
</I>&gt;<i>
</I>&gt;<i> The OCCI working group basically has two options now in order to deliver an
</I>&gt;<i> implementable draft this month as promised: follow Amazon or follow Google
</I>&gt;<i> (the whole while keeping an eye on other players including Sun and VMware).
</I>&gt;<i> Amazon use a simple but sprawling XML based API with a PHP style flat
</I>&gt;<i> namespace and while there is growing momentum around it, it's not without
</I>&gt;<i> its problems. Not only do I have my doubts about its scalability outside of
</I>&gt;<i> a public cloud environment (calls like 'DescribeImages' would certainly
</I>&gt;<i> choke with anything more than a modest number of objects and we're talking
</I>&gt;<i> about potentially millions) but there are a raft of intellectual property
</I>&gt;<i> issues as well:
</I>&gt;<i>
</I>&gt;<i>    - *Copyrights* (specifically section 3.3 of the Amazon Software License&lt;<A HREF="http://aws.amazon.com/asl/">http://aws.amazon.com/asl/</A>&gt;)
</I>&gt;<i>    prevent the use of Amazon's &quot;open source&quot; clients with anything other than
</I>&gt;<i>    Amazon's own services.
</I>&gt;<i>    - *Patents* pending like #20070156842&lt;<A HREF="http://appft1.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=1&amp;f=G&amp;l=50&amp;s1=%2220070156842%22.PGNR.&amp;OS=DN/20070156842&amp;RS=DN/20070156842">http://appft1.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=1&amp;f=G&amp;l=50&amp;s1=%2220070156842%22.PGNR.&amp;OS=DN/20070156842&amp;RS=DN/20070156842</A>&gt;cover the Amazon Web Services APIs and we know that Amazon have been known
</I>&gt;<i>    to use patents offensively&lt;<A HREF="http://en.wikipedia.org/wiki/1-Click#Barnes_.26_Noble">http://en.wikipedia.org/wiki/1-Click#Barnes_.26_Noble</A>&gt;against competitors.
</I>&gt;<i>    - *Trademarks* like #3346899&lt;<A HREF="http://tarr.uspto.gov/servlet/tarr?regser=serial&amp;entry=77054011">http://tarr.uspto.gov/servlet/tarr?regser=serial&amp;entry=77054011</A>&gt;prevent us from even referring to the Amazon APIs by name.
</I>&gt;<i>
</I>&gt;<i> While I wish the guys at Eucalyptus &lt;<A HREF="http://open.eucalyptus.com/">http://open.eucalyptus.com/</A>&gt; and
</I>&gt;<i> Canonical &lt;<A HREF="http://news.zdnet.com/2100-9595_22-292296.html">http://news.zdnet.com/2100-9595_22-292296.html</A>&gt; well and don't
</I>&gt;<i> have a bad word to say about Amazon Web Services, this is something I would
</I>&gt;<i> be bearing in mind while actively seeking alternatives, especially as Amazon
</I>&gt;<i> haven't worked out&lt;<A HREF="http://www.tbray.org/ongoing/When/200x/2009/01/20/Cloud-Interop">http://www.tbray.org/ongoing/When/200x/2009/01/20/Cloud-Interop</A>&gt;whether the interfaces are IP they should protect. Even if these issues were
</I>&gt;<i> resolved via royalty free licensing it would be very hard as a single vendor
</I>&gt;<i> to compete with truly open standards (RFC 4287: Atom Syndication Format&lt;<A HREF="http://tools.ietf.org/html/rfc4287">http://tools.ietf.org/html/rfc4287</A>&gt;and RFC
</I>&gt;<i> 5023: Atom Publishing Protocol &lt;<A HREF="http://tools.ietf.org/html/rfc5023">http://tools.ietf.org/html/rfc5023</A>&gt;) which
</I>&gt;<i> were developed at IETF by the community based on loose consensus and running
</I>&gt;<i> code.
</I>&gt;<i>
</I>&gt;<i> So what does all this have to do with an API for Cloud Infrastructure
</I>&gt;<i> Services (IaaS)? In order to facilitate future extension my initial designs
</I>&gt;<i> for OCCI have been as modular as possible. In fact the core protocol is
</I>&gt;<i> completely generic, describing how to connect to a single entry point,
</I>&gt;<i> authenticate, search, create, retrieve, update and delete resources, etc.
</I>&gt;<i> all using existing standards including HTTP, TLS, OAuth and Atom. On top of
</I>&gt;<i> this are extensions for compute, network and storage resources as well as
</I>&gt;<i> state control (start, stop, restart), billing, performance, etc. in much the
</I>&gt;<i> same way as Google have extensions for different data types (e.g. contacts
</I>&gt;<i> vs YouTube movies).
</I>&gt;<i>
</I>&gt;<i> Simply by standardising at this level OCCI may well become the HTTP of
</I>&gt;<i> Cloud Computing.
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.ogf.org/pipermail/occi-wg/attachments/20090506/3649b3d2/attachment.html">http://www.ogf.org/pipermail/occi-wg/attachments/20090506/3649b3d2/attachment.html</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="https://www.ogf.org/pipermail/occi-wg/2009-May/000399.html">[occi-wg] Is OCCI the HTTP of Cloud Computing?
</A></li>
	<LI>Next message: <A HREF="https://www.ogf.org/pipermail/occi-wg/2009-May/000403.html">[occi-wg] Is OCCI the HTTP of Cloud Computing?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="https://www.ogf.org/pipermail/occi-wg/2009-May/date.html#395">[ date ]</a>
              <a href="https://www.ogf.org/pipermail/occi-wg/2009-May/thread.html#395">[ thread ]</a>
              <a href="https://www.ogf.org/pipermail/occi-wg/2009-May/subject.html#395">[ subject ]</a>
              <a href="https://www.ogf.org/pipermail/occi-wg/2009-May/author.html#395">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.ogf.org/mailman/listinfo/occi-wg">More information about the occi-wg
mailing list</a><br>
</body>
<!-- Mirrored from www.ogf.org/pipermail/occi-wg/2009-May/000395.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 20 Oct 2022 22:35:22 GMT -->
</html>
