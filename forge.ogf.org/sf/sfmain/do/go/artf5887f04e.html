



























<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<!-- Mirrored from forge.ogf.org/sf/sfmain/do/go/artf5887?selectedTab=comments by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Oct 2022 15:51:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
  <title>SourceForge : artf5887: Queries using WS-Enumeration</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  
  <link rel="stylesheet" type="text/css" href="../../../../css/styles_new.css" />
  <link rel="shortcut icon" href="../../../../sf-images/icons/favicon.ico" />
  <script language="JavaScript" src="../../../js/sf_functions.js" type="text/javascript"></script>
  


  <script type="text/javascript" src="../../../include/calendar/calendar.js"></script>
  <script type="text/javascript" src="../../../include/calendar/lang/calendar-en.js"></script>
  <link type="text/css" rel="stylesheet" href="../../../include/calendar/calendar-system.css"/>

  <script language="JavaScript">
  // calendar /////////////////////////////////////////////////////////////////
  //
  var calendar = null;

  function calSelected(cal, date) {
    cal.sel.value = date;

    var updateFlexElements = document.getElementsByName('updateF' + cal.sel.name.substring(1));
    if ((typeof updateFlexElements != "undefined") && (updateFlexElements.length > 0)) {
	var elem = updateFlexElements[0];
	if (elem.type == "checkbox") {
	   elem.checked = true;
	}
    }
    cal.callCloseHandler();
  } // calSelected

  function calCloseHandler(cal) {
   cal.hide();
  } // calCloseHandler

  function calShow(id) {
    var el = document.getElementById(id);
    if (calendar != null) {
      calendar.hide();		// hide the existing calendar
      calendar.parseDate(el.value); // set it to a new date
    } else {
      var cal = new Calendar(false, null, calSelected, calCloseHandler);
      var now = new Date();
      calendar = cal;
      calendar.setDateFormat('mm/dd/y');
      calendar.setRange(now.getFullYear() - 10, now.getFullYear() + 10);
      calendar.weekNumbers = false;
      calendar.create();
    }
    calendar.sel = el;
    calendar.showAtElement(el);
    //calendar.addEvent(document, "mousedown", checkCalendar);
    return false;
  } // calShow
  </script>
  
  
  
</head>

  <body>


<!-- SourceForge masthead begin -->


<script type="text/javascript" src="../../../../sf-help/RoboHelp_CSH.js"></script>
<script type="text/javascript">
                      var helpRoot = '/sf-help/en/index.htm>HelpWin';
    
    // show help for a topic
    function showTopicHelp(topicId) {
	// First, close the help menu
	closeMenu(activeButton);
	RH_ShowHelp(0, helpRoot, HH_HELP_CONTEXT, topicId);
    }

    // show help for a topic
    function showTopicHelpDirectly(topicId) {
	RH_ShowHelp(0, helpRoot, HH_HELP_CONTEXT, topicId);
    }

    // show the help table of contents
    function showHelpContents() {
	// First, close the help menu
	closeMenu(activeButton);
	RH_ShowHelp(0, helpRoot, HH_DISPLAY_TOC, 0);
    }

    // show the help index
    function showHelpIndex() {
	// First, close the help menu
	closeMenu(activeButton);
	RH_ShowHelp(0, helpRoot, HH_DISPLAY_INDEX, 0);
    }

    // show the help index (not from a menu)
    function showHelpIndexFromLink() {
	RH_ShowHelp(0, helpRoot, HH_DISPLAY_INDEX, 0);
    }
</script>

<div id="ProjectMenu" class="menu">
    <a class="menuItem" href="../myProjectsd3a8.html?selectedTab=my">My Projects</a>
    <a class="menuItem" href="../myProjectsa641.html?selectedTab=all">All Projects</a>
</div>

<div id="SearchMenu" class="menu">
  <a class="menuItem" href="../../../search/do/quickJump.html" onClick="window.open('../../../search/do/quickJump.html', 'quickjumpwindow', 'width=540,height=263'); closeMenu(activeButton); return false">Quick Jump</a>
  <a class="menuItem" id="search" href="../../../search/do/search.html">Search</a>
</div>

<div id="HelpMenu2" class="menu">
<a class="menuItem" href="../../../wiki/do/viewPage/projects.ggf-info/wiki/HomePage.html">GridForge  Help</a>

    <a class="menuItem" href="javascript:showTopicHelp(40)">Help for this Page</a>
<a class="menuItem" href="javascript:showHelpContents()">Help Contents</a>
<a class="menuItem" href="javascript:showHelpIndex()">Help Index</a>
<a class="menuItem" href="../../../../sf-help/en/doc/User_Guide.pdf">User Guide</a>
<div class="menuItemSep"></div>
<a class="menuItem" href="../../../global/do/about.html" onclick="javascript:closeMenu(activeButton); window.open('../../../global/do/about.html','sfpabout','height=450,width=600'); return false;">About SourceForge</a>
</div>

<table width="100%" border="0" cellpadding="0" cellspacing="0" class="mastHeadBackground">
 <tr>
  <td>
   <table width="300" border="0" cellpadding="0" cellspacing="0" class="mastHeadLink">
     <tr class="mastHeadLinkSpacing">
       <td nowrap="nowrap" valign="middle"><a href="../home.html" target="_top"><img src="../../../../sf-images/masthead/logo-custom.gif" border="0" align="absmiddle"><img src="../../../../ogf-it/gf_masthead.gif" border="0" align="absmiddle"></a></td>
                    <td nowrap="nowrap" class="mastHeadLink"><a href="../home.html" target="_top">Home</a></td>
       <td nowrap="nowrap" class="mastHeadLinkSpacing"> </td>
                      <td nowrap="nowrap" class="mastHeadLink"><a href="../listProjects.html" target="_top">Projects</a></td>
       <td nowrap="nowrap" class="mastHeadLinkSpacing"> </td>
               <td nowrap="nowrap" class="mastHeadLink"><a href="#" onclick="return buttonClick(this, 'SearchMenu');">Search<img src="../../../../sf-images/masthead/dropdown.gif" width="7" height="4" hspace="2" border="0"></a></td>
     
          
     
     </tr>
   </table>
  </td>
  <td align="right">
    <table border="0" cellspacing="0" cellpadding="0" class="mastHeadLink">
      <tr class="mastHeadLink">
                              <form action="https://forge.ogf.org/sf/sfmain/do/login" method="POST" id="globalLogin" name="login">
<INPUT type="HIDDEN" name="sfsubmit">

              <input type="hidden" name="returnToUrl" value="http://localhost:8080/sf/sfmain/do/go/artf5887?selectedTab=comments"/>
              <td nowrap="nowrap">User</td>
              <td nowrap="nowrap"><input type="text" name="username" class="inputfield" size="8"/></td>
              <td nowrap="nowrap">Password</td>
              <td nowrap="nowrap"><input type="password" name="password" class="inputfield" size="8" onkeypress="javascript:submitLoginOnEnter(event)" /></td>
              <td nowrap="nowrap"><a href="javascript:submitForm(document.getElementById('globalLogin'), 'submit');">Log In</a></td>
            </form>
            <td nowrap="nowrap"><img src="../../../../sf-images/masthead/vertical_line.gif" width="1" height="19" hspace="4"></td>
                    <td nowrap="nowrap"><a href="#" onclick="return buttonClick(this, 'HelpMenu2');">Help<img src="../../../../sf-images/masthead/dropdown.gif" width="7" height="4" hspace="2" border="0"></a></a></td>
              </tr>
    </table>
  </td>
  </tr>
  <tr>
    <td colspan="2" class="black"><img src="../../../../sf-images/misc/pixel.gif" width="1" height="1"></td>
  </tr>
</table>

<!-- SourceForge masthead end -->

<!-- SourceForge buttonbar begin -->
<table class="TopMenu">
    <tr class="ButtonRow">
        <td class="VerticalSeparatorNoBorder"><img src="../../../../sf-images/misc/white.gif" border="0" height="40" width="1"></td>
                   <td class="Button " onclick="window.location = '../../../projects/rus-wg.html'; return false;"><a href="../../../projects/rus-wg.html" target="_top"><img src="../../../../sf-images/project/project-homeicon.gif" width="25" height="20" border="0"><br>Project&nbsp;Home</a></td>
                                    <td class="SelectedLeft"><img src="../../../../sf-images/misc/pixel.gif" border="0" height="1" width="4"></td>
           <td class="Button Selected" onclick="window.location = '../../../tracker/do/listTrackers/projects.rus-wg/tracker.html'; return false;"><a href="../../../tracker/do/listTrackers/projects.rus-wg/tracker.html" target="_top"><img src="../../../../sf-images/project/project-trackericon.gif" width="25" height="20" border="0"><br>Tracker</a></td>
           <td class="SelectedRight"><img src="../../../../sf-images/misc/pixel.gif" border="0" height="1" width="4"/></td>
                  <td class="VerticalSeparatorNoBorder"><img src="../../../../sf-images/misc/white.gif" border="0" height="40" width="1"></td>
                             <td class="Button " onclick="window.location = '../../../docman/do/listDocuments/projects.rus-wg/docman.html'; return false;"><a href="../../../docman/do/listDocuments/projects.rus-wg/docman.html" target="_top"><img src="../../../../sf-images/project/project-documentsicon.gif" width="25" height="20" border="0"><br>Documents</a></td>
                  <td class="VerticalSeparator"><img src="../../../../sf-images/misc/white.gif" border="0" height="40" width="1"></td>
                             <td class="Button " onclick="window.location = '../../../taskmgr/do/viewSummary/projects.rus-wg/taskmgr.html'; return false;"><a href="../../../taskmgr/do/viewSummary/projects.rus-wg/taskmgr.html" target="_top"><img src="../../../../sf-images/project/project-tasksicon.gif" width="25" height="20" border="0"><br>Tasks</a></td>
                  <td class="VerticalSeparator"><img src="../../../../sf-images/misc/white.gif" border="0" height="40" width="1"></td>
                             <td class="Button " onclick="window.location = '../../../scm/do/listRepositories/projects.rus-wg/scm.html'; return false;"><a href="../../../scm/do/listRepositories/projects.rus-wg/scm.html" target="_top"><img src="../../../../sf-images/project/project-scmicon.gif" width="25" height="20" border="0"><br>Source&nbsp;Code</a></td>
                  <td class="VerticalSeparator"><img src="../../../../sf-images/misc/white.gif" border="0" height="40" width="1"></td>
                             <td class="Button " onclick="window.location = '../../../discussion/do/listForums/projects.rus-wg/discussion.html'; return false;"><a href="../../../discussion/do/listForums/projects.rus-wg/discussion.html" target="_top"><img src="../../../../sf-images/project/project-forumsicon.gif" width="25" height="20" border="0"><br>Discussions</a></td>
                 <td class="VerticalSeparator"><img src="../../../../sf-images/misc/white.gif" border="0" height="40" width="1"></td>

                             <td class="Button " onclick="window.location = '../../../frs/do/viewSummary/projects.rus-wg/frs.html'; return false;"><a href="../../../frs/do/viewSummary/projects.rus-wg/frs.html" target="_top"><img src="../../../../sf-images/project/project-releasesicon.gif" width="25" height="20" border="0"><br>File Releases</a></td>
                  <td class="VerticalSeparator"><img src="../../../../sf-images/misc/white.gif" border="0" height="40" width="1"></td>
                             <td class="Button " onclick="window.location = '../../../wiki/do/viewPage/projects.rus-wg/wiki/HomePage.html'; return false;"><a href="../../../wiki/do/viewPage/projects.rus-wg/wiki/HomePage.html" target="_top"><img src="../../../../sf-images/project/project-wikiicon.gif" width="25" height="20" border="0"><br>Wiki</a></td>
                  <td class="VerticalSeparator"><img src="../../../../sf-images/misc/white.gif" border="0" height="40" width="1"></td>
                             <td class="Button " onclick="window.location = '../projectAdmin/projects-50.html'; return false;"><a href="../projectAdmin/projects-50.html" target="_top"><img src="../../../../sf-images/project/project-projectadminicon.gif" width="25" height="20" border="0"><br>Project&nbsp;Admin</a></td>
                  <td class="VerticalSeparator"><img src="../../../../sf-images/misc/white.gif" border="0" height="40" width="1"></td>
                           <td class="ButtonEnd"></td>
             </tr>

  <tr class="ShadowRow">
        
                  <td colspan="2"></td>
            <td class="SelectedLeft"></td>
      <td class="Selected"></td>
      <td class="SelectedRight"></td>
              <td colspan="16"></td>
  </tr>
  </table>

<!-- SourceForge buttonbar end -->

<!-- SourceForge content-area begin -->
<div class="contentArea">

<!-- SourceForge crumbs begin -->
<div style="padding-bottom: 2px;">
  <div style="float: right">
    <a href="../../../tracker/do/searchTracker/projects.rus-wg/tracker-2.html">Search Tracker</a>
  </div>
 <span class="mainnavHeader"><strong class="ProjectProminent">Project: RUS-WG</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../../go/projects.rus-wg/tracker.html">Trackers</a>&nbsp;&gt;&nbsp;<a href="../../../go/projects.rus-wg/tracker-2.html">Doc Change Request</a>&nbsp;&gt;&nbsp;</span><strong>View Artifact</strong></div>
<!-- SourceForge crumbs end -->

<!-- SourceForge messages begin -->







<div style="padding-bottom: 2px; padding-top: 6px;">



</div>
<!-- SourceForge messages end -->

<!-- SourceForge content begin -->
<div style="padding-top: 10px; width: auto;">



















<table class="ItemDetailContainer">
  <tr class="ContainerHeader">
    <td>
      





      Artifact artf5887 : Queries using WS-Enumeration
   </td>
  </tr>
  <tr>
    <td class="ItemDetailContainerCell">
    <table class="ItemDetailTable">
      <tr>
        <td class="ItemDetailName">Tracker:</td>
        <td class="ItemDetailValue">Doc Change Request</td>
      </tr>
      <tr>
        <td class="ItemDetailName">Title:</td>
        <td class="ItemDetailValue">Queries using WS-Enumeration</td>
      </tr>
      <tr>
        <td class="ItemDetailName">Description:</td>
        <td class="ItemDetailValue"><pre class="text">Notes to slide 9 (add a operation to query using a WS-Enumeration):

OGSA-DAI is doing a very similar thing by buffering the result set in memory
and allowing clients to return part of it at a time. This does however not
help performance since the same amount of data is returned in the end.
The main reason for this proposal was not performance but scalability, 
especially the size of the SOAP messages that are returned for large result
sets.

Some DBs allow you to use cursors to return results, WS-Enumeration would fit
in nicely with that. 

WS-Enumeration is part of the WS-Transfer stack, in WS-RF you would create
a new resource and use that to return the result in smaller packets.
Can WS-Enumeration be used outside the WS-Transfer stack?

A RUSReplyTooBig fault is a good thing to have, however it can be difficult to
use, most implementation just behave very rude when they run out of memory
(e.g. just go offline, or reply with authentication/authorization faults).
One caution is that this is a very dynamic fault, so even a query with only one
record could be a too big if another very large query is under processing.

The operation could be tied together with the query operation if you allow
for an extra parameter specifying the maximum size of the result and allowing
the server to either return the result or a WS-Enumeration in case the result
size exceeded the maximum.
The important point here is that the server cannot make this decision 
unilaterally, the client must also be able to specify its limitations.</pre></td>
      </tr>
      <tr>
        <td class="ItemDetailName">Submitted By:</td>
        <td class="ItemDetailValue">
          <a href="../../../global/do/viewUser/noname.html">Gilbert Netzer</a>
        </td>
      </tr>
      <tr>
        <td class="ItemDetailName">Submitted On:</td>
        <td class="ItemDetailValue">05/28/2007 4:35 AM EDT</td>
      </tr>
      <tr>
        <td class="ItemDetailName">Last Modified:</td>
        <td class="ItemDetailValue">07/12/2007 11:00 PM EDT</td>
      </tr>
      
    </table>
    </td>
  </tr>
  <tr class="ContainerFooter">
    <td>
      <div class="AlignRight">
        
      </div>
     </td>
  </tr>
</table>

</br>


<table class="TabTable" cellpadding="0" cellspacing="0" border="0">
 <tr><td><img src="../../../../sf-images/tabs/first_active_tab.gif" width="9" height="21"></td><td width="0" background="../../../../sf-images/tabs/tab_active_middle.gif" class="TabBody"><a href="artf5887f04e.html?selectedTab=comments">Status / Comments</a></td>
<td><img src="../../../../sf-images/tabs/active_inactive_tab.gif" width="19" height="21"></td><td width="0" background="../../../../sf-images/tabs/tab_inactive_middle.gif" class="TabBody"><a href="artf5887276a.html?selectedTab=history">Change Log</a></td>
<td><img src="../../../../sf-images/tabs/inactive_inactive_tab.gif" width="19" height="21"></td><td width="0" background="../../../../sf-images/tabs/tab_inactive_middle.gif" class="TabBody"><a href="artf58874202.html?selectedTab=associations">Associations (2)</a></td>
<td><img src="../../../../sf-images/tabs/inactive_inactive_tab.gif" width="19" height="21"></td><td width="0" background="../../../../sf-images/tabs/tab_inactive_middle.gif" class="TabBody"><a href="artf588768fb.html?selectedTab=attachments">Attachments</a></td><td><img src="../../../../sf-images/tabs/inactive_last_tab.gif" width="19" height="21"></td>
<td width="100%" background="../../../../sf-images/tabs/horiz_notab_background.gif">&nbsp;</td></tr><tr class="TabHeader"><td colspan="11" nowrap><img src="../../../../sf-images/misc/pixel.gif" width="1" height="1"></td></tr></table>
    















<style type="text/css">
.transitionRequiredFieldMarkInstruction {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    font-size: 11px;
    color: #FFF;
    background-color: #CC3300;
    padding-left:2px;
    padding-right:2px;
    vertical-align:middle;
}
.transitionRequiredFieldMark {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    font-size: 11px;
    color: white;
    background-color: white;
    padding-left:2px;
    padding-right:2px;
    vertical-align:middle;
}
.transitionRequiredFieldError {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    font-size: 11px;
    color: white;
    background-color: white;
    padding-left:2px;
    padding-right:2px;
    vertical-align:middle;
}
</style>



<script type="text/javascript" language="Javascript1.1"> 

<!-- Begin 

     var bCancel = false; 

    function validateViewArtifactForm(form) {                                                                   
        if (bCancel) 
      return true; 
        else 
       return validateInteger(form) && validateRequired(form) && validateIntRange(form); 
   } 

    function IntegerValidations () { 
     this.aa = new Array("actualHours", "Actual Hours needs to be a positive integer.", new Function ("varName", "this.min='0'; this.max='2147483647';  return this[varName];"));
     this.ab = new Array("estimatedHours", "Estimated Hours needs to be a positive integer.", new Function ("varName", "this.min='0'; this.max='2147483647';  return this[varName];"));
    } 

    function required () { 
     this.aa = new Array("title", "???en.viewArtifactForm.title??? is a required field.", new Function ("varName", " return this[varName];"));
     this.ab = new Array("description", "???en.viewArtifactForm.description??? is a required field.", new Function ("varName", " return this[varName];"));
    } 

    function intRange () { 
     this.aa = new Array("actualHours", "Actual Hours needs to be a positive integer.", new Function ("varName", "this.min='0'; this.max='2147483647';  return this[varName];"));
     this.ab = new Array("estimatedHours", "Estimated Hours needs to be a positive integer.", new Function ("varName", "this.min='0'; this.max='2147483647';  return this[varName];"));
    } 



function validateFloatRange(form) {
                var isValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oRange = new floatRange();
                for (x in oRange) {
                    var field = form[oRange[x][0]];
                    
                    if ((field.type == 'text' ||
                         field.type == 'textarea') &&
                        (field.value.length > 0)) {
                        
                        var fMin = parseFloat(oRange[x][2]("min"));
                        var fMax = parseFloat(oRange[x][2]("max"));
                        var fValue = parseFloat(field.value);
                        if (!(fValue >= fMin && fValue <= fMax)) {
                            if (i == 0) {
                                focusField = field;
                            }
                            fields[i++] = oRange[x][1];
                            isValid = false;
                        }
                    }
                }
                if (fields.length > 0) {
                    focusField.focus();
                    alert(fields.join('\n'));
                }
                return isValid;
            }
function validateByte(form) {
                var bValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oByte = new ByteValidations();
                for (x in oByte) {
                	var field = form[oByte[x][0]];
                	
                    if (field.type == 'text' ||
                        field.type == 'textarea' ||
                        field.type == 'select-one' ||
						field.type == 'radio') {

						var value = '';
						// get field's value
						if (field.type == "select-one") {
							var si = field.selectedIndex;
							if (si >= 0) {
								value = field.options[si].value;
							}
						} else {
							value = field.value;
						}
                        
                        if (value.length > 0) {
                            if (!isAllDigits(value)) {
                                bValid = false;
                                if (i == 0) {
                                    focusField = field;
                                }
                                fields[i++] = oByte[x][1];

                            } else {

	                            var iValue = parseInt(value);
	                            if (isNaN(iValue) || !(iValue >= -128 && iValue <= 127)) {
	                                if (i == 0) {
	                                    focusField = field;
	                                }
	                                fields[i++] = oByte[x][1];
	                                bValid = false;
	                            }
                            }
						}
						
                    }
                }
                if (fields.length > 0) {
                   focusField.focus();
                   alert(fields.join('\n'));
                }
                return bValid;
            }
function validateMaxLength(form) {
                var isValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oMaxLength = new maxlength();
                for (x in oMaxLength) {
                    var field = form[oMaxLength[x][0]];
                    
                    if (field.type == 'text' ||
                        field.type == 'textarea') {
                        
                        var iMax = parseInt(oMaxLength[x][2]("maxlength"));
                        if (field.value.length > iMax) {
                            if (i == 0) {
                                focusField = field;
                            }
                            fields[i++] = oMaxLength[x][1];
                            isValid = false;
                        }
                    }
                }
                if (fields.length > 0) {
                   focusField.focus();
                   alert(fields.join('\n'));
                }
                return isValid;
            }
function validateRequired(form) {
                var isValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oRequired = new required();
                for (x in oRequired) {
                	var field = form[oRequired[x][0]];
                	
                    if (field.type == 'text' ||
                        field.type == 'textarea' ||
                        field.type == 'file' ||
                        field.type == 'select-one' ||
                        field.type == 'radio' ||
                        field.type == 'password') {
                        
                        var value = '';
						// get field's value
						if (field.type == "select-one") {
							var si = field.selectedIndex;
							if (si >= 0) {
								value = field.options[si].value;
							}
						} else {
							value = field.value;
						}
                        
                        sText = "\u3000";
                        rText = "\u0020";
                        while (true) {
                            dummy = value;
                            value = dummy.replace(sText, rText);
                            if (value == dummy) {
                                break;
                            }
                        }
                        if (trim(value) == '') {
                        
	                        if (i == 0) {
	                            focusField = field;
	                        }
	                        fields[i++] = oRequired[x][1];
	                        isValid = false;
                        }
                    }
                }
                if (fields.length > 0) {
                   focusField.focus();
                   alert(fields.join('\n'));
                }
                return isValid;
            }
function validateInteger(form) {
                var bValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oInteger = new IntegerValidations();
                for (x in oInteger) {
                	var field = form[oInteger[x][0]];

                    if (field.type == 'text' ||
                        field.type == 'textarea' ||
                        field.type == 'select-one' ||
                        field.type == 'radio') {
                        
                        var value = '';
						// get field's value
						if (field.type == "select-one") {
							var si = field.selectedIndex;
						    if (si >= 0) {
							    value = field.options[si].value;
						    }
						} else {
							value = field.value;
						}
                        
                        if (value.length > 0) {
                        
                            if (!isAllDigits(value)) {
                                bValid = false;
                                if (i == 0) {
	                                focusField = field;
	                            }
						        fields[i++] = oInteger[x][1];
						        
                            } else {
	                            var iValue = parseInt(value);
	                            if (isNaN(iValue) || !(iValue >= -2147483648 && iValue <= 2147483647)) {
	                                if (i == 0) {
	                                    focusField = field;
	                                }
	                                fields[i++] = oInteger[x][1];
	                                bValid = false;
	                           }
                           }
                       }
                    }
                }
                if (fields.length > 0) {
                   focusField.focus();
                   alert(fields.join('\n'));
                }
                return bValid;
            }

            function isAllDigits(argvalue) {
                argvalue = argvalue.toString();
                var validChars = "0123456789";
                var startFrom = 0;
                if (argvalue.substring(0, 2) == "0x") {
                   validChars = "0123456789abcdefABCDEF";
                   startFrom = 2;
                } else if (argvalue.charAt(0) == "0") {
                   validChars = "01234567";
                   startFrom = 1;
                } else if (argvalue.charAt(0) == "-") {
                    startFrom = 1;
                }
                
                for (var n = startFrom; n < argvalue.length; n++) {
                    if (validChars.indexOf(argvalue.substring(n, n+1)) == -1) return false;
                }
                return true;
            }
function validateRange(form) {
                return validateIntRange(form);
            }
function validateCreditCard(form) {
                var bValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oCreditCard = new creditCard();
                for (x in oCreditCard) {
                    if ((form[oCreditCard[x][0]].type == 'text' ||
                         form[oCreditCard[x][0]].type == 'textarea') &&
                        (form[oCreditCard[x][0]].value.length > 0)) {
                        if (!luhnCheck(form[oCreditCard[x][0]].value)) {
                            if (i == 0) {
                                focusField = form[oCreditCard[x][0]];
                            }
                            fields[i++] = oCreditCard[x][1];
                            bValid = false;
                        }
                    }
                }
                if (fields.length > 0) {
                    focusField.focus();
                    alert(fields.join('\n'));
                }
                return bValid;
            }

            /**
             * Reference: http://www.ling.nwu.edu/~sburke/pub/luhn_lib.pl
             */
            function luhnCheck(cardNumber) {
                if (isLuhnNum(cardNumber)) {
                    var no_digit = cardNumber.length;
                    var oddoeven = no_digit & 1;
                    var sum = 0;
                    for (var count = 0; count < no_digit; count++) {
                        var digit = parseInt(cardNumber.charAt(count));
                        if (!((count & 1) ^ oddoeven)) {
                            digit *= 2;
                            if (digit > 9) digit -= 9;
                        };
                        sum += digit;
                    };
                    if (sum == 0) return false;
                    if (sum % 10 == 0) return true;
                };
                return false;
            }

            function isLuhnNum(argvalue) {
                argvalue = argvalue.toString();
                if (argvalue.length == 0) {
                    return false;
                }
                for (var n = 0; n < argvalue.length; n++) {
                    if ((argvalue.substring(n, n+1) < "0") ||
                        (argvalue.substring(n,n+1) > "9")) {
                        return false;
                    }
                }
                return true;
            }
function validateDate(form) {
               var bValid = true;
               var focusField = null;
               var i = 0;
               var fields = new Array();
               oDate = new DateValidations();
               for (x in oDate) {
                   var value = form[oDate[x][0]].value;
                   var datePattern = oDate[x][2]("datePatternStrict");
                   if ((form[oDate[x][0]].type == 'text' ||
                        form[oDate[x][0]].type == 'textarea') &&
                       (value.length > 0) &&
                       (datePattern.length > 0)) {
                     var MONTH = "MM";
                     var DAY = "dd";
                     var YEAR = "yyyy";
                     var orderMonth = datePattern.indexOf(MONTH);
                     var orderDay = datePattern.indexOf(DAY);
                     var orderYear = datePattern.indexOf(YEAR);
                     if ((orderDay < orderYear && orderDay > orderMonth)) {
                         var iDelim1 = orderMonth + MONTH.length;
                         var iDelim2 = orderDay + DAY.length;
                         var delim1 = datePattern.substring(iDelim1, iDelim1 + 1);
                         var delim2 = datePattern.substring(iDelim2, iDelim2 + 1);
                         if (iDelim1 == orderDay && iDelim2 == orderYear) {
                            dateRegexp = new RegExp("^(\\d{2})(\\d{2})(\\d{4})$");
                         } else if (iDelim1 == orderDay) {
                            dateRegexp = new RegExp("^(\\d{2})(\\d{2})[" + delim2 + "](\\d{4})$");
                         } else if (iDelim2 == orderYear) {
                            dateRegexp = new RegExp("^(\\d{2})[" + delim1 + "](\\d{2})(\\d{4})$");
                         } else {
                            dateRegexp = new RegExp("^(\\d{2})[" + delim1 + "](\\d{2})[" + delim2 + "](\\d{4})$");
                         }
                         var matched = dateRegexp.exec(value);
                         if(matched != null) {
                            if (!isValidDate(matched[2], matched[1], matched[3])) {
                               if (i == 0) {
                                   focusField = form[oDate[x][0]];
                               }
                               fields[i++] = oDate[x][1];
                               bValid =  false;
                            }
                         } else {
                            if (i == 0) {
                                focusField = form[oDate[x][0]];
                            }
                            fields[i++] = oDate[x][1];
                            bValid =  false;
                         }
                     } else if ((orderMonth < orderYear && orderMonth > orderDay)) {
                         var iDelim1 = orderDay + DAY.length;
                         var iDelim2 = orderMonth + MONTH.length;
                         var delim1 = datePattern.substring(iDelim1, iDelim1 + 1);
                         var delim2 = datePattern.substring(iDelim2, iDelim2 + 1);
                         if (iDelim1 == orderMonth && iDelim2 == orderYear) {
                             dateRegexp = new RegExp("^(\\d{2})(\\d{2})(\\d{4})$");
                         } else if (iDelim1 == orderMonth) {
                             dateRegexp = new RegExp("^(\\d{2})(\\d{2})[" + delim2 + "](\\d{4})$");
                         } else if (iDelim2 == orderYear) {
                             dateRegexp = new RegExp("^(\\d{2})[" + delim1 + "](\\d{2})(\\d{4})$");
                         } else {
                             dateRegexp = new RegExp("^(\\d{2})[" + delim1 + "](\\d{2})[" + delim2 + "](\\d{4})$");
                         }
                         var matched = dateRegexp.exec(value);
                         if(matched != null) {
                             if (!isValidDate(matched[1], matched[2], matched[3])) {
                                 if (i == 0) {
                                     focusField = form[oDate[x][0]];
                                 }
                                 fields[i++] = oDate[x][1];
                                 bValid =  false;
                              }
                         } else {
                             if (i == 0) {
                                 focusField = form[oDate[x][0]];
                             }
                             fields[i++] = oDate[x][1];
                             bValid =  false;
                         }
                     } else if ((orderMonth > orderYear && orderMonth < orderDay)) {
                         var iDelim1 = orderYear + YEAR.length;
                         var iDelim2 = orderMonth + MONTH.length;
                         var delim1 = datePattern.substring(iDelim1, iDelim1 + 1);
                         var delim2 = datePattern.substring(iDelim2, iDelim2 + 1);
                         if (iDelim1 == orderMonth && iDelim2 == orderDay) {
                             dateRegexp = new RegExp("^(\\d{4})(\\d{2})(\\d{2})$");
                         } else if (iDelim1 == orderMonth) {
                             dateRegexp = new RegExp("^(\\d{4})(\\d{2})[" + delim2 + "](\\d{2})$");
                         } else if (iDelim2 == orderDay) {
                             dateRegexp = new RegExp("^(\\d{4})[" + delim1 + "](\\d{2})(\\d{2})$");
                         } else {
                             dateRegexp = new RegExp("^(\\d{4})[" + delim1 + "](\\d{2})[" + delim2 + "](\\d{2})$");
                         }
                         var matched = dateRegexp.exec(value);
                         if(matched != null) {
                             if (!isValidDate(matched[3], matched[2], matched[1])) {
                                 if (i == 0) {
                                     focusField = form[oDate[x][0]];
                                  }
                                  fields[i++] = oDate[x][1];
                                  bValid =  false;
                              }
                          } else {
                              if (i == 0) {
                                  focusField = form[oDate[x][0]];
                              }
                              fields[i++] = oDate[x][1];
                              bValid =  false;
                          }
                     } else {
                         if (i == 0) {
                             focusField = form[oDate[x][0]];
                         }
                         fields[i++] = oDate[x][1];
                         bValid =  false;
                     }
                  }
               }
               if (fields.length > 0) {
                  focusField.focus();
                  alert(fields.join('\n'));
               }
               return bValid;
            }

	    function isValidDate(day, month, year) {
	        if (month < 1 || month > 12) {
                    return false;
                }
                if (day < 1 || day > 31) {
                    return false;
                }
                if ((month == 4 || month == 6 || month == 9 || month == 11) &&
                    (day == 31)) {
                    return false;
                }
                if (month == 2) {
                    var leap = (year % 4 == 0 &&
                               (year % 100 != 0 || year % 400 == 0));
                    if (day>29 || (day == 29 && !leap)) {
                        return false;
                    }
                }
                return true;
            }
function validateIntRange(form) {
                var isValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oRange = new intRange();
                for (x in oRange) {
                    var field = form[oRange[x][0]];
                    
                    if ((field.type == 'text' ||
                         field.type == 'textarea') &&
                        (field.value.length > 0)) {
                        
                        var iMin = parseInt(oRange[x][2]("min"));
                        var iMax = parseInt(oRange[x][2]("max"));
                        var iValue = parseInt(field.value);
                        if (!(iValue >= iMin && iValue <= iMax)) {
                            if (i == 0) {
                                focusField = field;
                            }
                            fields[i++] = oRange[x][1];
                            isValid = false;
                        }
                    }
                }
                if (fields.length > 0) {
                    focusField.focus();
                    alert(fields.join('\n'));
                }
                return isValid;
            }
function validateShort(form) {
                var bValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oShort = new ShortValidations();
                for (x in oShort) {
                	var field = form[oShort[x][0]];
                	
                    if (field.type == 'text' ||
                        field.type == 'textarea' ||
                        field.type == 'select-one' ||
                        field.type == 'radio') {
                        
                        var value = '';
						// get field's value
						if (field.type == "select-one") {
							var si = field.selectedIndex;
							if (si >= 0) {
								value = field.options[si].value;
							}
						} else {
							value = field.value;
						}
                        
                        if (value.length > 0) {
                            if (!isAllDigits(value)) {
                                bValid = false;
                                if (i == 0) {
                                    focusField = field;
                                }
                                fields[i++] = oShort[x][1];

                            } else {
                        
	                            var iValue = parseInt(value);
	                            if (isNaN(iValue) || !(iValue >= -32768 && iValue <= 32767)) {
	                                if (i == 0) {
	                                    focusField = field;
	                                }
	                                fields[i++] = oShort[x][1];
	                                bValid = false;
	                            }
	                       }
                       }
                    }
                }
                if (fields.length > 0) {
                   focusField.focus();
                   alert(fields.join('\n'));
                }
                return bValid;
            }
function validateFloat(form) {
                var bValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oFloat = new FloatValidations();
                for (x in oFloat) {
                	var field = form[oFloat[x][0]];
                	
                    if (field.type == 'text' ||
                        field.type == 'textarea' ||
                        field.type == 'select-one' ||
                        field.type == 'radio') {
                        
                    	var value = '';
						// get field's value
						if (field.type == "select-one") {
							var si = field.selectedIndex;
							if (si >= 0) {
							    value = field.options[si].value;
							}
						} else {
							value = field.value;
						}
                        
                        if (value.length > 0) {
                            // remove '.' before checking digits
                            var tempArray = value.split('.');
                            var joinedString= tempArray.join('');

                            if (!isAllDigits(joinedString)) {
                                bValid = false;
                                if (i == 0) {
                                    focusField = field;
                                }
                                fields[i++] = oFloat[x][1];

                            } else {
	                            var iValue = parseFloat(value);
	                            if (isNaN(iValue)) {
	                                if (i == 0) {
	                                    focusField = field;
	                                }
	                                fields[i++] = oFloat[x][1];
	                                bValid = false;
	                            }
                            }
                        }
                    }
                }
                if (fields.length > 0) {
                   focusField.focus();
                   alert(fields.join('\n'));
                }
                return bValid;
            }
function validateEmail(form) {
                var bValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oEmail = new email();
                for (x in oEmail) {
                    if ((form[oEmail[x][0]].type == 'text' ||
                         form[oEmail[x][0]].type == 'textarea') &&
                        (form[oEmail[x][0]].value.length > 0)) {
                        if (!checkEmail(form[oEmail[x][0]].value)) {
                            if (i == 0) {
                                focusField = form[oEmail[x][0]];
                            }
                            fields[i++] = oEmail[x][1];
                            bValid = false;
                        }
                    }
                }
                if (fields.length > 0) {
                    focusField.focus();
                    alert(fields.join('\n'));
                }
                return bValid;
            }

            /**
             * Reference: Sandeep V. Tamhankar (stamhankar@hotmail.com),
             * http://javascript.internet.com
             */
            function checkEmail(emailStr) {
               if (emailStr.length == 0) {
                   return true;
               }
               var emailPat=/^(.+)@(.+)$/;
               var specialChars="\\(\\)<>@,;:\\\\\\\"\\.\\[\\]";
               var validChars="\[^\\s" + specialChars + "\]";
               var quotedUser="(\"[^\"]*\")";
               var ipDomainPat=/^(\d{1,3})[.](\d{1,3})[.](\d{1,3})[.](\d{1,3})$/;
               var atom=validChars + '+';
               var word="(" + atom + "|" + quotedUser + ")";
               var userPat=new RegExp("^" + word + "(\\." + word + ")*$");
               var domainPat=new RegExp("^" + atom + "(\\." + atom + ")*$");
               var matchArray=emailStr.match(emailPat);
               if (matchArray == null) {
                   return false;
               }
               var user=matchArray[1];
               var domain=matchArray[2];
               if (user.match(userPat) == null) {
                   return false;
               }
               var IPArray = domain.match(ipDomainPat);
               if (IPArray != null) {
                   for (var i = 1; i <= 4; i++) {
                      if (IPArray[i] > 255) {
                         return false;
                      }
                   }
                   return true;
               }
               var domainArray=domain.match(domainPat);
               if (domainArray == null) {
                   return false;
               }
               var atomPat=new RegExp(atom,"g");
               var domArr=domain.match(atomPat);
               var len=domArr.length;
	       if (len < 2) {
		   return false;
	       }
               if (domArr[len-1].length < 1) {
                   return false;
               }
               return true;
            }
function validateMask(form) {
                var isValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oMasked = new mask();
                for (x in oMasked) {
                    var field = form[oMasked[x][0]];
                    
                    if ((field.type == 'text' || 
                         field.type == 'textarea') && 
                         (field.value.length > 0)) {
                        
                        if (!matchPattern(field.value, oMasked[x][2]("mask"))) {
                            if (i == 0) {
                                focusField = field;
                            }
                            fields[i++] = oMasked[x][1];
                            isValid = false;
                        }
                    }
                }
                
                if (fields.length > 0) {
                   focusField.focus();
                   alert(fields.join('\n'));
                }
                return isValid;
            }

            function matchPattern(value, mask) {
               return mask.exec(value);
            }
function validateMinLength(form) {
                var isValid = true;
                var focusField = null;
                var i = 0;
                var fields = new Array();
                oMinLength = new minlength();
                for (x in oMinLength) {
                    var field = form[oMinLength[x][0]];
                    
                    if (field.type == 'text' ||
                        field.type == 'textarea') {
                        
                        var iMin = parseInt(oMinLength[x][2]("minlength"));
                        if ((field.value.length > 0) && (field.value.length < iMin)) {
                            if (i == 0) {
                                focusField = field;
                            }
                            fields[i++] = oMinLength[x][1];
                            isValid = false;
                        }
                    }
                }
                if (fields.length > 0) {
                   focusField.focus();
                   alert(fields.join('\n'));
                }
                return isValid;
            }

//End --> 
</script>


<table id="artifactSummary" class="ItemDetailContainer" style="padding: 0px;">
  
  <tr>
    <td class="ItemDetailContainerCell">
      
        
      
     <form name="viewArtifactForm" method="post" action="https://forge.ogf.org/sf/tracker/do/viewArtifact/projects.rus-wg/tracker.doc_change_request/artf5887" enctype="multipart/form-data" id="viewArtifactForm"><INPUT type="HIDDEN" name="sfsubmit">
      <input type="hidden" name="version" value="105">
      <input type="hidden" name="title" value="Queries using WS-Enumeration">
      <input type="hidden" name="description" value="Notes to slide 9 (add a operation to query using a WS-Enumeration):

OGSA-DAI is doing a very similar thing by buffering the result set in memory
and allowing clients to return part of it at a time. This does however not
help performance since the same amount of data is returned in the end.
The main reason for this proposal was not performance but scalability, 
especially the size of the SOAP messages that are returned for large result
sets.

Some DBs allow you to use cursors to return results, WS-Enumeration would fit
in nicely with that. 

WS-Enumeration is part of the WS-Transfer stack, in WS-RF you would create
a new resource and use that to return the result in smaller packets.
Can WS-Enumeration be used outside the WS-Transfer stack?

A RUSReplyTooBig fault is a good thing to have, however it can be difficult to
use, most implementation just behave very rude when they run out of memory
(e.g. just go offline, or reply with authentication/authorization faults).
One caution is that this is a very dynamic fault, so even a query with only one
record could be a too big if another very large query is under processing.

The operation could be tied together with the query operation if you allow
for an extra parameter specifying the maximum size of the result and allowing
the server to either return the result or a WS-Enumeration in case the result
size exceeded the maximum.
The important point here is that the server cannot make this decision 
unilaterally, the client must also be able to specify its limitations.">      
      
      <table class="Container">
        <tr>
          <td width="50%" valign="top">
            <table id="artifactSummaryFields" class="ItemDetailTable">
              <tr>
                <td><strong>Status</strong></td>
                <td>&nbsp;</td>
              </tr>

              
                <tr>
                  <td  class="ItemDetailName">
	            
	            
                        Group: <span class="transitionRequiredFieldMark" id="trf_fild4269">*</span>
                    
                  </td>
                  <td  class="ItemDetailValue">
                    
                      
                      
                        
                      
                    
                  </td>
                </tr>
              

              
                <tr>
                  <td class="ItemDetailName">
	            
                        Status:<span class="TextRequired">*</span>
                    
	            
                  </td>
                  <td  class="ItemDetailValue">
                    
                      
                      
                        Open
                      
                    
                  </td>
                </tr>
              

              
                <tr>
                  <td class="ItemDetailName">
	            
	            
                        Category: <span class="transitionRequiredFieldMark" id="trf_fild4270">*</span>
                    
                  </td>
                  <td class="ItemDetailValue">
                    
                      
                      
                        
                      
                    
                  </td>
                </tr>
              

              
                <tr>
                  <td class="ItemDetailName">
	            
	            
                        Customer: <span class="transitionRequiredFieldMark" id="trf_fild4271">*</span>
                    
                  </td>
                  <td class="ItemDetailValue">
                    
                      
                      
                        
                      
                    
                  </td>
              </tr>
              

              <tr>
                <td class="ItemDetailName">Priority: <span class="transitionRequiredFieldMark" id="trf_priority">*</span></td>
                <td class="ItemDetailValue">
                  
                    
                    
                        3
                    
                  
                </td>
              </tr>
              <tr>
                <td class="ItemDetailName">Assigned To: <span class="transitionRequiredFieldMark" id="trf_assignedTo">*</span></td>
                <td class="ItemDetailValue">
                  
                    
                    
                        None</a>
                    
                  
                </td>
              </tr>
              
		
                <tr>
                  <td class="ItemDetailName">Reported in Release: <span class="transitionRequiredFieldMark" id="trf_fild4287">*</span></td>
                  <td class="ItemDetailValue">
                    
                      
                    
                        
                    
                  
                  </td>
                </tr>
		
		
                <tr>
                  <td class="ItemDetailName">Fixed in Release: <span class="transitionRequiredFieldMark" id="trf_fild4288">*</span></td>
                  <td class="ItemDetailValue">
                    
                      
                    
                        
                    
                  
                  </td>
                </tr>
		
              
              
              
              
                <tr>
                  <td class="ItemDetailName">
	            
	            
                        Estimated Hours: <span class="transitionRequiredFieldMark" id="trf_fild4285">*</span>
                    
                  </td>
                  <td class="ItemDetailValue">
                    
                      
                      
                        0
                        <input type="hidden" name="estimatedHours" value="0">
                      
                    
                  </td>
                </tr>
	      
	      
              
              
              
              
                <tr>
                  <td class="ItemDetailName">
	            
	            
                        Actual Hours: <span class="transitionRequiredFieldMark" id="trf_fild4286">*</span>
                    
                  </td>
                  <td class="ItemDetailValue">
                    
                      
                      
                        0
                        <input type="hidden" name="actualHours" value="0">
                      
                    
                  </td>
                </tr>
	      
	      
              

              
              
              
            </table>
             <!-- END STATUS CELL -->
          </td>
          
          <!-- END COMMENT CREATE CELL -->
        </tr>
        

      </table>
      </form>

    </td>
  </tr>
  
  <tr class="ContainerHeader">
    <td>
      <strong>Comments</strong>
    </td>
  </tr>
  











  
  

  
  <tr class="OddRow">
    <td>
      <table width="100%" class="NoBorders" id="auditTrail[0]">
        <tr>
          <td colspan="3" valign="top">
            <a href="../../../global/do/viewUser/xchen1027.html">Xiaoyu Chen</a>: 07/12/2007 11:01 PM EDT
          </td>
        </tr>

        <!-- user comments -->
        
          <tr>
            <td width="3%" valign="top">&nbsp;</td>
            <td width="8%" valign="top"><strong>Comment:</strong></td>
            <td width="89%">
              
                <pre class="text">First of all, i would like to clarify and extend requirements on RUS query operation a little bit by classification of RUS operations in more generic 
way. 
The RUS operations can be roughly classifed by two main criteria:
1) Batch processing vs. Atomic Processing
Most of RUS operations are being defined targetting at batch processing on multiple usage record instances. However, this never stops the 
implementation put restrictions on atomic processing on single usage record per transaction. 
2) Synchronous vs. Asynchronous processing
Being conformative to WS-I profile, the RUS operations are essentially stateless and only allow synchronous processing. There are potential problems 
for implementations, in paritcular for querying large amount of usage records/data. Then asynchronous processing is introduced for this porblem 
specifically. 
_But essentially, the potential issue can happen to any RUS operations._ 
for example, the RUS::insertUsageRecords allowing batch insertion of multiple usage records, which could be huge as well. The WS-enumeration 
specification does not do any good for insertion as well as other operations like update and deletion. Luckily there is not really any meaningful 
output for these operations. But the client-side does expect operation results and "RUSRecordIdList" as defined in current spec (version 1.7). We can 
easily add another status code, PENDING, within _RUS:operationResult_ and a session id within _RUSRecordIdList_ element corresponding to each usage 
record sequence as immediate returns for insert, update, deletion operations. Then we might need another operation to get the real execution status 
back to the client, _RUS::getOperationResult_ ?

Then coming back to WS-Enumeration and RUS query operations.
I basically agree on what Gilbert proposed solution by introducing WS-Enumeration operations quoted from Gilbert's message:

&gt;To sum up I want to suggest the following:
&gt;1. Replace the extractUsageRecords operation &gt;with the &lt;wsen:Enumerate&gt; method.
Would it be better to keep _RUS::extractUsageRecords operation (you mean version 1.9? because in version 1.7 is "RUS::extractRUSUsageRecords) for 
synchronous query, while using _wsen:Enumerate_ and _wsen:Pull_ for asynchrous query????

&gt;2. State the servers SHOULD implement the &gt;&lt;wsman:OptimizeEnumeration&gt; extension.
I see the WS-management document, which covers many aspects on related specifications inculding ws-enumeration. I don't whether this document is 
approved or draft. But it would be easier to narrow specification dependencies for RUS specification? since the _RUS::extractUsageRecords_ does work 
on returning small number of usage records. 

&gt;3. State the client MUST understand the result of a 
&gt;&lt;wsman:OptimizeEnumeration&gt; extension if they &gt;used this extension in their request.
If leaving ws-management out scope, this point is not useful any more (see comments 2). 

cheers!
</pre>
              
            </td>
          </tr>
        
        <!-- attachments -->
        
        <!-- attachments removed -->
        

        <!-- actions -->
        <tr>
          <td width="3%" valign="top">&nbsp;</td>
          <td width="8%" valign="top"><strong>Action:</strong></td>
          <td width="89%">
            
              
              <strong>
                Update
                
                  
                  
                  
                
              </strong>
              <br/>
              
            
          </td>
        </tr>
      </table>
    </td>
  </tr>

  
  

  
  <tr class="EvenRow">
    <td>
      <table width="100%" class="NoBorders" id="auditTrail[1]">
        <tr>
          <td colspan="3" valign="top">
            <a href="../../../global/do/viewUser/noname.html">Gilbert Netzer</a>: 07/10/2007 5:13 AM EDT
          </td>
        </tr>

        <!-- user comments -->
        
          <tr>
            <td width="3%" valign="top">&nbsp;</td>
            <td width="8%" valign="top"><strong>Comment:</strong></td>
            <td width="89%">
              
                <pre class="text">After studying the WS-Enumeration sepcification (<a class="external" target="wikiext" href="http://www.w3.org/Submission/WS-Enumeration/">http://www.w3.org/Submission/WS-Enumeration/</a>) more closely, I have a few thoughts on how to implement
 a form of querying the RUS that can handle large result sets more memory and resource efficient.

To sum up I want to suggest the following:

1. Replace the extractUsageRecords operation with the &lt;wsen:Enumerate&gt;
   method.
2. State the servers SHOULD implement the &lt;wsman:OptimizeEnumeration&gt;
   extension.
3. State the client MUST understand the result of a 
   &lt;wsman:OptimizeEnumeration&gt; extension if they used this extension in 
   their request.


First of all I think we should use WS-Enumeration for accessing a "large" result set in handy pieces. The advantage would be that existing enumeration
 implementations (on both server and client side) can be used to do the actual data transfer. Such implementations will probably also show up in 
middleware toolkits. For instance the next version of the Globus Toolkit will contain a WS-Enumeration implementation. Besides the advantage for 
implementors, this would also mean that we can save us the trouble of specifying our own flavor of enumeration that essentially duplicates the 
functionality of an existing specification. The downside is that the WS-Enumeration is not part of WS-RF and therefore duplicates some of the 
lifecycle management functionality of the WS-RF (via the Renew, GetStatus, Release and EnumerationEnd operations). I do however not think that this is
 a big issue.

In WS-Enumeration the optional Enumerate operation is used to request a new enumeration from the data source, in our case this would be the RUS. In 
this request a filter condition can be specified using the &lt;wsen:Filter&gt; element. This element can be of any given dialect, however currently only the
 XPath dialect is specified. This basically is equivalent to the specification of the searchTerm currently used by the extraction methods (extract*) 
so it could actually replace the extraction methods of the RUS.

One problem with the WS-Enumeration specification is that a client always has to use at least two requests (one Enumerate and one Pull operation) to 
get the requested data even if the result contains only a small number of data items. This problem was already addressed by the WS-Management 
specification (<a class="external" target="wikiext" href="http://www.dmtf.org/standards/published_documents/DSP0226.pdf">http://www.dmtf.org/standards/published_documents/DSP0226.pdf</a>) which provides a extension &lt;wsman:OptimizeEnumeration&gt; using the WS-
Enumeration extensiability points to accomplish this in a backward compatible manner. The RUS specification could leverage this to actually accomplish
 a method to extract UsageRecord data in a very similar way that to what is currently possible plus add good support for large result sets.

The problem with this approach could be that it makes the RUS specification dependent on two other specifications (WS-Enumeration and parts of WS-
Management), but overall I would still consider this a worthwile approach.</pre>
              
            </td>
          </tr>
        
        <!-- attachments -->
        
        <!-- attachments removed -->
        

        <!-- actions -->
        <tr>
          <td width="3%" valign="top">&nbsp;</td>
          <td width="8%" valign="top"><strong>Action:</strong></td>
          <td width="89%">
            
              
              <strong>
                Update
                
                  
                  
                  
                
              </strong>
              <br/>
              
            
          </td>
        </tr>
      </table>
    </td>
  </tr>

  
  

  
  <tr class="OddRow">
    <td>
      <table width="100%" class="NoBorders" id="auditTrail[2]">
        <tr>
          <td colspan="3" valign="top">
            <a href="../../../global/do/viewUser/noname.html">Gilbert Netzer</a>: 07/05/2007 10:59 AM EDT
          </td>
        </tr>

        <!-- user comments -->
        
          <tr>
            <td width="3%" valign="top">&nbsp;</td>
            <td width="8%" valign="top"><strong>Comment:</strong></td>
            <td width="89%">
              
                <pre class="text">After having another quick look at the WS-Enumeration to refresh my memory,
I think the following things should be true:

The WS-Enumeration defines all the operations that are needed to get the
results out of a given enumeration (Pull,GetStatus) and to manage the
lifetime of the enumeration (Renew,Release,EnumerationEnd). These
operations are already defined, so we should have to redefine them.

The Enumerate method is optional and can be replaced by an equivalent
method that returns a Enumerate response message.

In the Enumerate response message, a &lt;wsa:ReplyTo&gt; element can be specified
which should then be used for any operations on that enumeration.

This gives two possibilities:

1 Use the same endpoint reference as the RUS.
In this case the implementor will have to also provide the WS-Enumeration
defined methods in the RUS service. However they should be in the wsen
namespace so the RUS spec should not be affected.

2 Use a different endpoint reference
Now the endpoint is different, so this should not affect RUS at all.

In any case we however need the Enumerate response from the WS-Enumeration
spec and I would think that we should import it from their schema and not
copy-paste it, if that is possible, to avoid inconsequences.

The interesting question would be if we could define a query method that
can either return the whole result (if it is small) in a response message
the we define or a Enumerate response message (if it is a large result set)
according to the WS-Enumerate specification. If that is possible I would
vote using only a single method, although it makes life harder for the
client because that needs to be able to handle the complexity.

If that is not possible, I would suggest to import (reference in the
specification) the Enumerate operation from the WS-Enumerate spec as it
seems to provide the features we would like (XPath as search/filter
expression).

But then again I am not sure if that works like I outlined above, I am not
that good with wsdls so please tell me if I am right or wrong about the
import things.</pre>
              
            </td>
          </tr>
        
        <!-- attachments -->
        
        <!-- attachments removed -->
        

        <!-- actions -->
        <tr>
          <td width="3%" valign="top">&nbsp;</td>
          <td width="8%" valign="top"><strong>Action:</strong></td>
          <td width="89%">
            
              
              <strong>
                Update
                
                  
                  
                  
                
              </strong>
              <br/>
              
            
          </td>
        </tr>
      </table>
    </td>
  </tr>

  
  

  
  <tr class="EvenRow">
    <td>
      <table width="100%" class="NoBorders" id="auditTrail[3]">
        <tr>
          <td colspan="3" valign="top">
            <a href="../../../global/do/viewUser/noname.html">Gilbert Netzer</a>: 07/05/2007 10:00 AM EDT
          </td>
        </tr>

        <!-- user comments -->
        
          <tr>
            <td width="3%" valign="top">&nbsp;</td>
            <td width="8%" valign="top"><strong>Comment:</strong></td>
            <td width="89%">
              
                <pre class="text">Copied from <a class="sfobject" href="artf5934.html">artf5934</a>: Comment on 07/05/2007 by Xiaoyu Chen

2). Regarding RUS operations, the reason i got stucked somehow is an important signal from stakeholders about query operation. 
"The RUS specificaiton is hard to be conformed only if the query operations providing reliable extraction of usage records based on following contexts

:
first of all, as a specification, it should gives implementation guides to solve potential problems and makes reliable recommendataions. Which means, 

the specification should protect the RUS server from being crashed when returning large amount of data."
We agree to propose a "RUSTooComplexFault". However this never really solves returning huge-data to the client. Some implementation strongly requires 

a "steam" type return for stateful connection to the database. They request the complex queries always return what user asked even taking longer time.

 However, this would not work through Web service, which is stateless essentially and will throw session out error if taking too long time to get SOAP

 response message back. 

So i reviewed OSGA-DAI, WS-DAI, WS-Enumeration, WS-Context and other relevant specification and implementations. There is still no satisfiable 
solutions for this issue from the perspective of service interface definitions. OSGA-DAI provides an implementation-specific service interface, which 

is more or less like the operation defined in the WS-Enumeration specification:

GetFully Operation
Inputs: 
The name of a session known to a data service resource. 
The name of an open output stream known to the session. 
The session name and stream name are expected to be conjoined with a colon (:). 
Outputs: 
Data - a string, a chunk of valid XML or a byte array. 

GetNBlocks Operation
Inputs: 
The name of a session known to a data service resource. 
The name of an open output stream known to the session. 
The session name and stream name are expected to be conjoined with a colon (:). 
The number of blocks of data to be retrieved. 
Outputs: 
A block of data - a string, a chunk of valid XML or a byte array. 

Gilbert proposed the WS-Enumeration, and define a new operation for returning "wsen:EnumreationContext" type. That could be a solution. However, how 
to integrate the WS-Enumeration datatype and operations into RUS operations is another issue. 
* import WS-Enumeration WSDL within the RUS WSDL?
* define a new context data type for enumeration context within the RUS WSDL?</pre>
              
            </td>
          </tr>
        
        <!-- attachments -->
        
        <!-- attachments removed -->
        

        <!-- actions -->
        <tr>
          <td width="3%" valign="top">&nbsp;</td>
          <td width="8%" valign="top"><strong>Action:</strong></td>
          <td width="89%">
            
              
              <strong>
                Update
                
                  
                  
                  
                
              </strong>
              <br/>
              
            
          </td>
        </tr>
      </table>
    </td>
  </tr>

  
  

  
  <tr class="OddRow">
    <td>
      <table width="100%" class="NoBorders" id="auditTrail[4]">
        <tr>
          <td colspan="3" valign="top">
            <a href="../../../global/do/viewUser/noname.html">Gilbert Netzer</a>: 05/28/2007 4:58 AM EDT
          </td>
        </tr>

        <!-- user comments -->
        
          <tr>
            <td width="3%" valign="top">&nbsp;</td>
            <td width="8%" valign="top"><strong>Comment:</strong></td>
            <td width="89%">
              
                <pre class="text">Comments by EMail from Xiaoyu Chen, 05/18/2007 05:43 PM

Again for a big returns, there are many solutions to deal with. like OGSA-DAI, which maintains the results within memory and allows the client to 
query chucks of data with many sessions. But Do you think a seperate fault for "TooBigResutlsFault" can be put into the specification, 'cos for some 
grid project, which deploys RUS implementation at site-level and operates on relatively same number of usage records. Or a RUS implementation only 
allows operations upon aggregate usage records. This fault will not thrown for these implementations at all. I can understand why people in OGF 20 
proposal various solutions for this, because they are thinking from implementor perspectives. But for specification, we can only recommend 
implemenations but not supposed to specify solutions. 
 
So my proposed solutions are: 
Put the "RUSQueryTooComplexFault" into  RUS::InvalidFault category;
Put "TooBigResultsFault" into some defined faults (do you have any recommendataions? );
Besides, do you remember the Fault schema in spec. v1.9 proposal allows custom defined RUS faults, but this would undermise standardisation and it is 
implementation's reponsibility to consider how to extends RUS faults for their custom implementations. </pre>
              
            </td>
          </tr>
        
        <!-- attachments -->
        
        <!-- attachments removed -->
        

        <!-- actions -->
        <tr>
          <td width="3%" valign="top">&nbsp;</td>
          <td width="8%" valign="top"><strong>Action:</strong></td>
          <td width="89%">
            
              
              <strong>
                Update
                
                  
                  
                  
                
              </strong>
              <br/>
              
            
          </td>
        </tr>
      </table>
    </td>
  </tr>

  
  

  
  <tr class="EvenRow">
    <td>
      <table width="100%" class="NoBorders" id="auditTrail[5]">
        <tr>
          <td colspan="3" valign="top">
            <a href="../../../global/do/viewUser/noname.html">Gilbert Netzer</a>: 05/28/2007 4:35 AM EDT
          </td>
        </tr>

        <!-- user comments -->
        
        <!-- attachments -->
        
        <!-- attachments removed -->
        

        <!-- actions -->
        <tr>
          <td width="3%" valign="top">&nbsp;</td>
          <td width="8%" valign="top"><strong>Action:</strong></td>
          <td width="89%">
            
              
              <strong>
                Create
                
                  
                  
                  
                
              </strong>
              <br/>
              
                
                <br/>
              
            
          </td>
        </tr>
      </table>
    </td>
  </tr>


</table>

  

<br>
<table class="ContainerBody" width="100%">
  <tr>
    <td>
      <div class="AlignRight">
        <div class="Button"><div class="Left">&nbsp;</div><div class="Middle"><a href="../../../tracker/do/listArtifacts/projects.rus-wg/tracker.html">Return</a></div><div class="Right">&nbsp;</div></div>

        







        <div class="ButtonSpace"></div>
        








      </div>
    </td>
  </tr>
</table>
</div>
<!-- SourceForge content end -->

</div>
<!-- SourceForge content-area end -->

<div id="PageLoaded" style="display: none;"></div>


<!-- forge.gridforum.org footer.html -->
<br> <hr>
<table width='100%'> 
 <tr>
  <td align='left'>   <a href='../../../../../www.ogf.org/index.html' target='_blank' style='border: 0 px;'><img src='../../../../ogf-it/opengridforum.gif' alt='The Open Grid Forum' style='border:0px white solid;'></a><td>
  <td align='center'> <a href='mailto:webmaster@ogf.org'>Contact Webmaster</a> 
                    | <a href="../../../tracker/do/createArtifact/projects.ggf-info/tracker.html">Report a problem</a>
                    | <a href="../../../wiki/do/viewPage/projects.ggf-info/wiki/HomePage.html">GridForge Help</a>
                    </td>
  <td align='right'>  
<!--		<img src='/ogf-it/powered_by_dell.gif' alt='Powered by Dell'> -->
<!-- Begin DigiCert/ClickID site seal HTML and JavaScript -->
<div id="DigiCertClickID_sxSDRU4L">
  <a href="http://www.digicert.com/">SSL Certificates</a>
</div>
<script type="text/javascript">
var __dcid = __dcid || [];__dcid.push(["DigiCertClickID_sxSDRU4L", "10", "m", "black", "sxSDRU4L"]);(function(){var cid=document.createElement("script");cid.type="text/javascript";cid.async=true;cid.src=("https:" === document.location.protocol ? "https://" : "http://")+"seal.digicert.com/seals/cascade/seal.min.js";var s = document.getElementsByTagName("script");var ls = s[(s.length - 1)];ls.parentNode.insertBefore(cid, ls.nextSibling);}());
</script>
<!-- End DigiCert/ClickID site seal HTML and JavaScript -->
  </td>
 </tr>
</table>
<!-- google analytics code -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-6775861-2");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>

<!-- Mirrored from forge.ogf.org/sf/sfmain/do/go/artf5887?selectedTab=comments by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Oct 2022 15:51:59 GMT -->
</html>
