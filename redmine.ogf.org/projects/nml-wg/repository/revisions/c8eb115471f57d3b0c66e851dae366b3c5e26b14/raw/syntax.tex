%!TEX root = nml-base.tex

\section{Syntax}
\label{s:syntax}

The Network Markup Language has two different normative syntaxes. The syntaxes are in regular XML defined using an XML Schema (XSD), and another in OWL RDF/XML syntax, defined in an OWL schema.
The OWL syntax is aimed at Semantic Web-oriented applications, the XML syntax is suitable for any application. These syntaxes are defined in Appendices \ref{s:xmlschema} and \ref{s:owlschema} respectively. These syntaxes follow the model as defined in section~\ref{s:schema}, should there be any inconsistencies between the syntaxes or the syntaxes and the model, the definitions in section~\ref{s:schema} take precedence.


\subsection{XML Syntax} % (fold)
\label{sub:xml}

An NML object is represented as an XML element. For example:
\begin{lstlisting}
<nml:BidirectionalLink />
\end{lstlisting}

An NML attribute or parameter is represented as either an XML attribute, XML child element or text value of the XML element. The table list the mapping for the attributes and parameters defined in this document:

\begin{tabular}{|l|c|c|c|}
\hline
\textbf{XML representation} & \textbf{Attribute} & \textbf{Child element} & \textbf{Text of element} \\
\hline
\textbf{NML attribute or parameter} & id & name & value \\
 & adaptationFunction & address & values \\
 & encoding & lat & \\
 & labeltype & long & \\
 & version & alt & \\
 & noReturnTraffic & unlocode & \\
 & labelSwapping & start & \\
 &  & end & \\
% \hline
% \textbf{XML representation} & \textbf{Attribute} & \textbf{Child element} & \textbf{Text of element} \\
\hline
\end{tabular}

For example:
\begin{lstlisting}
<nml:Port id="urn:ogf:network:example.net:2013:port_X.1501:in">
  <nml:name>VLAN 1501 at Port X (in)</nml:name>
  <nml:Label labeltype="http://schemas.ogf.org/nml/2013/05/ethernet#vlan">1501</nml:Label>
</nml:Port>
\end{lstlisting}

Explicit relation are represented as a \texttt{<nml:Relation>} XML element, with the domain as the parent element, and the range as the child element. Implicit relations are not given: the range object is represented as an XML child element of the domain. 
Below is an example of an explicit relation:
\begin{lstlisting}
<nml:Port id="urn:ogf:network:example.net:2013:port_X:in">
  <nml:Relation type="http://schemas.ogf.org/nml/2013/05/base#isSource">
    <nml:Link id="urn:ogf:network:example.net:2013:linkA:XY"/>
  </nml:Relation>
</nml:Port>
\end{lstlisting}
And this is an example of an implicit relation:
\begin{lstlisting}
<nml:Topology id="urn:ogf:network:example.net:2013:Example_Network">
  <nml:Node id="urn:ogf:network:example.net:2013:example_node"/>
</nml:Port>
\end{lstlisting}

% subsection xml (end)




\subsection{OWL RDF/XML Syntax} % (fold)
\label{sub:owl}

An NML object is represented as an RDF subject. Exceptions are \emph{Label} and \emph{LabelGroup}.

An NML attribute or parameter is represented as a predicate. 

For example:
\begin{lstlisting}
<nml:Location id="urn:ogf:network:example.net:2013:redcity">
  <nml:name>Red City</nml:name>
  <nml:lat>30.600</nml:lat>
  <nml:long>12.640</nml:long>
</nml:Location>
\end{lstlisting}

Relations are represented as an RDF triplet, with the full URI of the attribute or parameter.  For example:
\begin{lstlisting}
<nml:Port rdf:about="urn:ogf:network:example.net:2013:port_X:in">
   <nml:isSource rdf:resource="urn:ogf:network:example.net:2013:linkA:XY"/>
</nml:Port>
\end{lstlisting}

A \emph{Label} is represented as a two triplets: one triplet defining a labeltype as a subproperty of the abstract Label resource, and one relating a Port or Link to a value using this labeltype.  For example:

\begin{lstlisting}
<rdf:Description rdf:about="http://schemas.ogf.org/nml/2013/05/ethernet#vlan">
  <owl:subPropertyOf rdf:resource="http://schemas.ogf.org/nml/2013/05/base#hasLabel"/>
</rdf:Description>
<nml:Port rdf:about="urn:ogf:network:example.net:2013:port_X.1501:in">
  <nmleth:vlan>1501</nmleth:vlan>
</nml:Port>
\end{lstlisting}

A \emph{LabelGroup} is represented as three triplets. The URI of the labeltype is not the URI of the predicate, to avoid naming clashes with the definition of the Label. Instead, the predicate of the LabelGroup is related to the predicate of the Label using the nml:labeltype property:
\begin{lstlisting}
<rdf:Description rdf:about="http://schemas.ogf.org/nml/2013/05/ethernet#vlans">
  <nml:labelType rdf:resource="http://schemas.ogf.org/nml/2013/05/ethernet#vlan"/>
  <owl:subPropertyOf rdf:resource="http://schemas.ogf.org/nml/2013/05/base#hasLabelGroup"/>
</rdf:Description>
<nml:PortGroup rdf:about="urn:ogf:network:example.net:2013:portgroup_X:out">
  <nmleth:vlans>1480-1530</nmleth:vlans>
</nml:PortGroup>
\end{lstlisting}



% subsection owl (end)


\subsection{Combining Object Descriptions} % (fold)
\label{sub:combining_descriptions}

A given object may have multiple attributes and relations. These attributes 
and relations may be described in different places in a syntax. It is up to 
the parser to combine all attributes and relations.

NML currently does not have a mechanism to check if a given description of an 
object is \emph{complete}. Thus, it does not distinguish between a full description 
of an object or merely a pointer to an object.

% Such distinction may be introduced by a future version of NML.

Parsers should be aware that the NML descriptions do not provide any guarantee 
regarding the integrity nor the authenticity of the description. Parsers are 
advised to use external mechanism to avoid that an erroneous description of an 
object in one (possibly malicious) topology description pollutes a correct 
description of the same object in another topology description.

% NOTE: this text is almost duplicate to the text in the security section?

% subsection combining_descriptions (end)

\subsection{Ordered Lists} % (fold)
\label{sub:ordered_lists}

The range of an \emph{isSerialCompoundLink} relation is an \emph{Ordered List}.

Neither XML nor OWL uses the \emph{Ordered List} directly in the syntax, and have a different way of constructing ordered lists. XML lists values with additional \emph{next} relations, while OWL uses a \emph{ListItem} class, and the \emph{item} and \emph{next} relations.

A \emph{ListItem} behaves as a class, while \emph{item} and \emph{next} behave like relations, with the exception that these classes and relations are local in scope.

This means that these relations are only valid within the scope of a given \emph{Ordered List}, but may not be valid in scope of a different \emph{Ordered List}. It also means that any identifier given to these classes may change when the objects are codified in a syntax.

For example, consider the following two decompositions of \emph{Link} \texttt{Link\_1\_2\_3} into shorter \emph{Links}:

\begin{itemize}
    \item \nmlrelation{Link\_1\_2\_3}{}{isSerialCompoundLink}{}{\lower3.5ex\vbox{\hbox{\framebox{Link\_1}}\hbox{\framebox{Link\_2}}\hbox{\framebox{Link\_3}}}}
    \item \nmlrelation{Link\_1\_2\_3}{}{isSerialCompoundLink}{}{\lower2ex\vbox{\hbox{\framebox{Link\_1}}\hbox{\framebox{Link\_2\_3}}}}
\end{itemize}

In the first \emph{Ordered List}, there is a \emph{next} relation from \texttt{Link\_1} to \texttt{Link\_2}, while in the second Ordered List, the \emph{next} relation is from \texttt{Link\_1} to \texttt{Link\_2\_3}.

In XML an \emph{Ordered List} can be constructed by using all objects in the list as child elements, and using a \emph{next} relation between consecutive objects in the list to denote ordering.

In OWL an \emph{Ordered List} can be constructed by creating as many \emph{ListItem} objects as there are items in the list. Each \emph{ListItem} object is correlated with the actual list item using the \emph{item} relation, while using a \emph{next} relation to point to the following \emph{ListItem}.
A predicate points to the first \emph{ListItem} in the \emph{Ordered List} to point to the whole list, which is chained using the \emph{next} relation.

See also the \emph{isSerialCompoundLink} examples in the example section.
% subsection ordered_lists (end)
